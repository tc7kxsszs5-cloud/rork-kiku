import { useChat, type UseChatOptions } from "@ai-sdk/react";
import {
  DefaultChatTransport,
  lastAssistantMessageIsCompleteWithToolCalls,
  type ToolUIPart,
  type UIMessage,
} from "ai";
import { fetch as expoFetch } from "expo/fetch";
import { useCallback, useMemo } from "react";
import * as z from "zod/v4";

import { BASE_URL, withBaseUrl } from "./api";

import "./polyfills";

import { getPostHogClient } from "./analytics";

const AGENT_URL = withBaseUrl("/agent/chat");

type Tool<T extends z.ZodType = z.ZodType> = {
  description: string;
  zodSchema: T;
  execute?: (input: z.infer<T>) => Promise<string> | string;
};

export function createRorkTool<T extends z.ZodType>(tool: Tool<T>): Tool<T> {
  return tool;
}

type TextPart = { type: "text"; text: string };
type ImagePart = { type: "image"; image: string };
type UserMessage = { role: "user"; content: string | (TextPart | ImagePart)[] };
type AssistantMessage = { role: "assistant"; content: string | TextPart[] };

// use generateObject and generate text only if you need a single generation.
// When the chat history and agentic flows are not needed
// For example, parsing image to text in mutation.
// or generating a caption for image, or a summary

export async function generateObject<T extends z.ZodType>(params: {
  messages: (UserMessage | AssistantMessage)[];
  schema: T;
}): Promise<z.infer<T>> {
  getPostHogClient()?.capture("RORK/GENERATE_OBJECT", {});
  const GENERATE_OBJECT_URL = new URL("/llm/object", BASE_URL).toString();
  const result = await fetch(GENERATE_OBJECT_URL, {
    method: "POST",
    body: JSON.stringify({
      messages: params.messages,
      schema: z.toJSONSchema(params.schema),
    }),
  });

  const data = await result.json();

  return params.schema.parse(data.object);
}

export async function generateText(
  params: string | { messages: (UserMessage | AssistantMessage)[] },
): Promise<string> {
  getPostHogClient()?.capture("RORK/GENERATE_TEXT", {});
  const GENERATE_TEXT_URL = new URL("/llm/text", BASE_URL).toString();
  const messages =
    typeof params === "string"
      ? [{ role: "user", content: params }]
      : params.messages;
  const result = await fetch(GENERATE_TEXT_URL, {
    method: "POST",
    body: JSON.stringify({ messages }),
  });

  const data = await result.json();

  return data.completion;
}

export function useRorkAgent<T extends Record<string, Tool<z.ZodType>>>(
  options: Omit<UseChatOptions<UIMessage>, "transport"> & {
    tools: T;
  },
) {
  const { addToolResult, ...rest } = useChat({
    ...options,
    sendAutomaticallyWhen: lastAssistantMessageIsCompleteWithToolCalls,
    transport: new DefaultChatTransport({
      fetch: expoFetch as unknown as typeof globalThis.fetch,
      api: AGENT_URL,
      body: () => {
        const toolsEntries = Object.entries(options.tools).map(
          ([name, tool]) => [
            name,
            {
              description: tool.description,
              jsonSchema: z.toJSONSchema(tool.zodSchema),
            },
          ],
        );

        return {
          tools: Object.fromEntries(toolsEntries),
        };
      },
    }),
    onToolCall: async ({ toolCall }) => {
      getPostHogClient()?.capture("RORK/USE_AGENT/TOOL_CALL", {
        toolName: toolCall.toolName,
      });
      const tool = options.tools[toolCall.toolName];

      if (!tool) {
        throw new Error(`Tool ${toolCall.dynamic} not found`);
      }

      if (!tool.execute) return;

      const result = await tool.execute(toolCall.input);
      addToolResult({
        toolCallId: toolCall.toolCallId,
        tool: toolCall.toolName,
        output: result,
      });
    },
  });

  const messages = useMemo(() => {
    return rest.messages.map((m) => {
      const parts = m.parts
        .map((p) => {
          if (p.type === "text") return p;
          if (p.type.startsWith("tool")) {
            const toolPart = p as ToolUIPart;
            const toolName = toolPart.type.replace(/^tool-/, "");

            return {
              ...(p as ToolUIPart),
              type: "tool",
              toolName,
            } satisfies Omit<ToolUIPart, "type"> & {
              type: "tool";
              toolName: string;
            };
          }

          return undefined;
        })
        .filter((p) => p !== undefined);

      return { ...m, parts };
    });
  }, [rest.messages]);

  const sendMessage = useCallback(
    (message: string | Parameters<typeof rest.sendMessage>[0]) => {
      getPostHogClient()?.capture("RORK/USE_AGENT/SEND_MESSAGE", {});
      if (typeof message === "string") {
        rest.sendMessage({
          text: message,
        });
      } else {
        rest.sendMessage(message);
      }
    },
    [rest],
  );

  return {
    ...rest,
    sendMessage,
    messages,
    addToolResult,
  };
}
